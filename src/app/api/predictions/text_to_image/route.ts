import { NextResponse } from "next/server";
import { genEffectResultId } from "@/backend/utils/genId";
import { createEffectResult } from "@/backend/service/effect_result";
import { reducePeriodRemainCountByUserId } from "@/backend/service/credit_usage";
import { generateCheck } from "@/backend/service/generate-_check";
import { generateImageByGemini } from "@/backend/lib/google";
import { uploadBufferToR2 } from "@/backend/lib/r2";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

// Simple per-user/IP rate limiter (best-effort within the same serverless instance)
const RL_WINDOW_MS = Number(process.env.TTI_RATE_WINDOW_MS || 10_000);
const rlMap: Map<string, number> = new Map();

function getClientKey(request: Request, userId?: string) {
  if (userId) return `u:${userId}`;
  const xf = request.headers.get("x-forwarded-for") || "";
  const ip = xf.split(",")[0]?.trim() || "unknown";
  return `ip:${ip}`;
}

export async function POST(request: Request) {
  const requestBody = await request.json();
  const {
    prompt,
    width,
    height,
    user_id,
    user_email,
    effect_link_name = "text-to-image",
    credit = 1,
  } = requestBody || {};

  // Basic rate limit (best-effort per instance)
  const key = getClientKey(request, user_id);
  const now = Date.now();
  const last = rlMap.get(key) || 0;
  if (now - last < RL_WINDOW_MS) {
    const retryMs = RL_WINDOW_MS - (now - last);
    return NextResponse.json(
      { detail: "Too many requests, please retry later", retry_after_ms: retryMs },
      { status: 429, headers: { "Retry-After": String(Math.ceil(retryMs / 1000)) } }
    );
  }
  rlMap.set(key, now);

  // Validate user and credit using existing checker
  const check = await generateCheck(user_id, user_email, String(credit));
  if (check !== 1) {
    // Forward the Response generated by generateCheck (401/402/403/...)
    return check as any;
  }

  const start = Date.now();
  try {
    // 1) Generate image via Gemini Images API
    const { bytes, mimeType } = await generateImageByGemini({ prompt, width, height });

    // 2) Upload to R2
    const resultId = genEffectResultId();
    const ext = mimeType.includes("png") ? "png" : mimeType.includes("webp") ? "webp" : "jpg";
    const objectKey = `ssat/images/${resultId}.${ext}`;
    const r2Url = await uploadBufferToR2(bytes, objectKey, mimeType);

    // 3) Persist effect_result as succeeded
    await createEffectResult({
      result_id: resultId,
      original_id: resultId,
      user_id: user_id,
      effect_id: 0,
      effect_name: effect_link_name,
      prompt: prompt,
      url: r2Url,
      status: "succeeded",
      original_url: "",
      storage_type: "R2",
      running_time: (Date.now() - start) / 1000,
      credit: credit,
      request_params: JSON.stringify(requestBody),
      created_at: new Date(),
    });

    // 4) Deduct credits (idempotent in practice when only called after success)
    await reducePeriodRemainCountByUserId(user_id, credit);

    // 5) Return prediction-like object for frontend compatibility
    const now = new Date().toISOString();
    return NextResponse.json(
      {
        id: resultId,
        status: "succeeded",
        output: r2Url,
        created_at: now,
        started_at: now,
        completed_at: now,
      },
      { status: 201 }
    );
  } catch (e: any) {
    console.error("Gemini text-to-image generation failed:", e?.message || e);
    return NextResponse.json({ detail: "Generation failed" }, { status: 500 });
  }
}
